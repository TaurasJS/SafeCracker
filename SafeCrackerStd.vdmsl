module SafeCrackerStd
exports all
definitions 

--@doc R1 represent the safe cracker generally (e.g. N wheels and M spokes) 
--@doc R1.1 instantiate the safe cracker to specific configuration 
--@doc R1.2 instantiate the wheels (4) and spokes (16) 

--@doc R2 find the safe combination/configuration to open the safe
--@doc R3 ensure that at least one combination exists
--@doc R4 capture the safe properties in your design
--@doc R5 ensure that the safe development is satisfiable

--@doc suggested configuration with certain openning combination
--	   this also suggests a fixed notion of spokes (i.e. where is 1st spoke)?
--	   OUTER = 27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10
--	   MID2  =  5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3
--	   MID1  = 10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10
--     INNER = 10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24
--
--	   certain wheels have overlays over intermitent spokes
--	   again this requires a notion of spoke positioning 
--	   MID1_OVERLAY  = 10,  2, 12, 17, 16, 9, 9, 15
--	   MID2_OVERLAY  =  1, 22,  6, 24, 24, 7, 5, 27
--     INNER_OVERLAY =  5,  4,  6,  6, 10, 1, 6,  4	
--
--	   secret sum is 40, yet also a game parameter

values
	MAX_WHEELS: nat1 = 4;
	MAX_SPOKES: nat1 = 16;
	SECRET_SUM: nat1 = 40;
	
types

	Value = nat1
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v <= SECRET_SUM - MAX_WHEELS + 1;

	OverValue = nat1 | <Empty>
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v <= SECRET_SUM - MAX_WHEELS + 1 or v = <Empty>;

	Rotate = nat
	inv r == r <= MAX_SPOKES and r >= 0;
	
	Spokes = nat1 
	--@todo how many spokes are possible?
	inv s == s <= MAX_SPOKES;
	
	Wheel = seq of Value
	inv w == len w = MAX_SPOKES; -- length of wheel must be equal to max spokes for the integrity of the game

	Overwheel = seq of OverValue
	inv ow == len ow = MAX_SPOKES; -- length of overlay wheel of non empty values is equal to MAX_SPOKES, half of them are filled out as <Empty>
	--@todo would you need to represent the wheels in combination?
	Wheels = seq of Wheel
	inv ws == len ws <= MAX_WHEELS; -- ammount of wheels must be equal or less to the MAX_WHEELS
	
	--@todo depending on design decisions you may need a notion of Overlay?
	Overlay = seq of Overwheel
	inv ovl == len ovl < MAX_WHEELS;
	
	-- Safe = set of Overwheel * set of Wheels
	-- inv s == card s.#1 <= card s.#2;
	
	Safe = Overlay * Wheels
	inv mk_(o, w) == len o = len w-1;

	--@todo a safe is not a combination; but a combination is part of a safe? 
	--in my case combinationn is 4 sequences of wheels that we would see if we saw the safe cracker puzzle from top-down. (wheels and overhweels combined).
	Combination = Wheels
	inv c == len c = 4;--???

	Rotations =  seq of Rotate
	inv r == len r = 3; -- First OUTER and MID2 don't rotate. Rotations are how many times other circle combinations (of inner and outer connected layers) were roateted, max 16 times.

values
	--GOOD_SAFE.#1(1) = 				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],

	GOOD_SAFE: Safe = mk_(
			[
				--INNER_OVERLAy
				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],
				--MID1_OVERLAY
				[1, <Empty>, 22, <Empty>, 6, <Empty>, 24, <Empty>, 24, <Empty>, 7, <Empty>, 5, <Empty>, 27,<Empty>],
				--MID2_OVERLAY
				[5, <Empty>, 4, <Empty>, 6, <Empty>, 6, <Empty>, 10, <Empty>, 1, <Empty>, 6, <Empty>, 4, <Empty>]
			],
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);

functions

	sum_values: ? -> Value
	sum_values(x) == 
		--@todo 
		is not yet specified;

	initial_safe: () -> Safe
	initial_safe() == 
		--@todo
		is not yet specified
	pre
		--@todo
		true
	post
		--@todo
		true;
		
	--@doc realises requirement R3
	combinations: Safe -> set of Combination
	combinations(s) ==
		--@todo
		is not yet specified
	pre true --@todo
	post true;--@todo

	valid_safe: Safe -> bool
	valid_safe(s) == 
		combinations(s) <> {};


--------------------------------------------------------------------------------------
--@doc you don't need the part below; 
--     it's useful for those who struggle with functions alone!
--------------------------------------------------------------------------------------

state State of
	safe: [Safe]
	sum: nat1
inv mk_State(-, sum) == 
	--@todo document system invariants
	sum <= SECRET_SUM
	--and 
	--(safe <> nil => valid_safe(safe))
init s == 
	--@todo choose adequate initialisation: nil will fail invariant. 
	s = mk_State(nil, SECRET_SUM)  
end

operations

--@doc resets safe to initial positon
resetSafe() == 
	(safe := nil)
ext wr safe
post safe = GOOD_SAFE;
	
--@doc configures the safe to a specific initial value
configureSafe(s: Safe) == 
	--@todo
	is not yet specified
ext wr safe
pre
	--@todo
	true 
post 
	safe = s;

openSafe() c: Combination ==
	--@todo 
	is not yet specified
ext rd safe
pre
	--@todo
	true
post
	--@todo
	true;

revealValues(c: Combination) r: ? ==
	is not yet specified
ext rd safe;
	
--@todo
traces


end SafeCrackerStd