module SafeCrackerStd
exports all
definitions 

--@doc R1 represent the safe cracker generally (e.g. N wheels and M spokes) 
--@doc R1.1 instantiate the safe cracker to specific configuration 
--@doc R1.2 instantiate the wheels (4) and spokes (16) 

--@doc R2 find the safe combination/configuration to open the safe
--@doc R3 ensure that at least one combination exists
--@doc R4 capture the safe properties in your design
--@doc R5 ensure that the safe development is satisfiable

--@doc suggested configuration with certain openning combination
--	   this also suggests a fixed notion of spokes (i.e. where is 1st spoke)?
--	   OUTER = 27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10
--	   MID2  =  5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3
--	   MID1  = 10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10
--     INNER = 10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24
--
--	   certain wheels have overlays over intermitent spokes
--	   again this requires a notion of spoke positioning 
--	   MID1_OVERLAY  = 10,  2, 12, 17, 16, 9, 9, 15
--	   MID2_OVERLAY  =  1, 22,  6, 24, 24, 7, 5, 27
--     INNER_OVERLAY =  5,  4,  6,  6, 10, 1, 6,  4	
--
--	   secret sum is 40, yet also a game parameter

values
	MAX_WHEELS: nat1 = 4;
	MAX_SPOKES: nat1 = 16;
	SECRET_SUM: nat1 = 40;
	
types

	Value = nat1
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v <= SECRET_SUM - MAX_WHEELS + 1;

	Collumnsum = nat1
	inv c == c <= SECRET_SUM;

	OverValue = nat1 | <Empty>
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v = <Empty> or v <= SECRET_SUM - MAX_WHEELS + 1;

	Rotate = nat
	inv r == r <= MAX_SPOKES and r >= 0;
	
	Spokes = nat1 
	--@todo how many spokes are possible?
	inv s == s <= MAX_SPOKES;
	
	Wheel = seq of Value
	inv w == len w = MAX_SPOKES; -- length of wheel must be equal to max spokes for the integrity of the game

	Overwheel = seq of OverValue
	inv ow == len ow = MAX_SPOKES; -- length of overlay wheel of non empty values is equal to MAX_SPOKES, half of them are filled out as <Empty>
	--@todo would you need to represent the wheels in combination?
	Wheels = seq of Wheel
	inv ws == len ws <= MAX_WHEELS; -- ammount of wheels must be equal or less to the MAX_WHEELS
	
	--@todo depending on design decisions you may need a notion of Overlay?
	Overlay = seq of Overwheel
	inv ovl == len ovl < MAX_WHEELS;
	
	-- Safe = set of Overwheel * set of Wheels
	-- inv s == card s.#1 <= card s.#2;
	
	Safe = Overlay * Wheels
	inv mk_(o, w) == len o = len w-1;

	--@todo a safe is not a combination; but a combination is part of a safe? 
	--in my case combinationn is 4 sequences of wheels that we would see if we saw the safe cracker puzzle from top-down. (wheels and overhweels combined).
	Combination = Wheels
	inv c == len c = 4;--???

	Rotations =  seq of Rotate
	inv r == len r = 3; -- First OUTER and MID2 don't rotate. Rotations are how many times other circle combinations (of inner and outer connected layers) were roateted, max 16 times.

values
	--GOOD_SAFE.#1(1) = 				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],

	GOOD_SAFE: Safe = mk_(
			[
				--INNER_OVERLAy
				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],
				--MID1_OVERLAY
				[1, <Empty>, 22, <Empty>, 6, <Empty>, 24, <Empty>, 24, <Empty>, 7, <Empty>, 5, <Empty>, 27,<Empty>],
				--MID2_OVERLAY
				[5, <Empty>, 4, <Empty>, 6, <Empty>, 6, <Empty>, 10, <Empty>, 1, <Empty>, 6, <Empty>, 4, <Empty>]
			],
			-- seq of seq of Value
			-- <= 4   = 16   
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);

		--Starting combination is equal to the default 4 wheels of safe. Just for the clarity. Not actual values
		--Only OUTER wheel is correct because it is not touched in my functions.
		STARTING_COMBINATION: Combination =(
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);

	OVERLAY_SAFE_INDEX: nat1 = 1;
	WHEEL_SAFE_INDEX: nat1 = 2;

functions


	--Following function sums up values of one collumn in a combination (Top down view of safe).
	--It takes a Combination and a natural number for the collumn to sum up.
	--Values for that collumn are summed up.
	sum_collumn: Combination * nat1 -> nat1
	sum_collumn(c, cn) == 
		let 
			x: Value = c(1)(cn),
			y: Value = c(2)(cn),
			z: Value = c(3)(cn),
			w: Value = c(4)(cn)
		in 
			x + y + z + w;
	--Checks if all collumn values in the current combination (top down reult of a specific rotation) equals to 40.
	--Returns True if it is.
	check_values: Combination -> bool
	check_values(x) == forall i in set {1,...,MAX_SPOKES} & sum_collumn(x, i) = SECRET_SUM;

	safe_to_combination: Safe -> Combination
	safe_to_combination(s) ==
		let
			combo: Combination = STARTING_COMBINATION, -- recursion or comprehensions

			for i = 1 to MAX_WHEELS-1 by 1 do
				for j = 1 to MAX_SPOKES by 1 do
					if s.#1(i)(j) <> <Empty> 
					then 
						combo(i)(j) = s.#1(i)(j)
					else
						combo(i)(j) = s.#2(i)(j)
		in
			combo;
			

	f: seq of seq of int -> seq of int 
	f(s) == 
		let 
			inner: Wheel = s(2)(1),
		    mid1 : Wheel = s(2)(2) 
		in
			inner ^ mid1   ;

	f(s) == s(2)(1) ^ s(2)(2)

	g: set1 of int -> int 
	g(s) == 
		let x in set s 
			be st (forall i in set s \ {x} & x <= i) 
		 in 
		 	x;
			

	initial_safe: () -> Safe
	initial_safe() == GOOD_SAFE -- maybe, useless. Consider deleting function.
	pre
		--@todo
		true
	post
		--@todo
		true;
		
	--@doc realises requirement R3
	combinations: Safe -> set of Combination
	combinations(s) ==
		--@todo
		is not yet specified
	pre true --@todo
	post true;--@todo

	valid_safe: Safe -> bool
	valid_safe(s) == 
		combinations(s) <> {};


--------------------------------------------------------------------------------------
--@doc you don't need the part below; 
--     it's useful for those who struggle with functions alone!
--------------------------------------------------------------------------------------

-- state State of
-- 	safe: [Safe]
-- 	sum: nat1
-- inv mk_State(-, sum) == 
-- 	--@todo document system invariants
-- 	sum <= SECRET_SUM
-- 	--and 
-- 	--(safe <> nil => valid_safe(safe))
-- init s == 
-- 	--@todo choose adequate initialisation: nil will fail invariant. 
-- 	s = mk_State(nil, SECRET_SUM)  
-- end

state S of 
	x: nat 
init s == s = mk_S(0)
end

operations

myloop(s: Safe) r: Combination == -- Example 
	(dcl comb: Combination := STARTING_COMBINATION;
		while (i > 10) do
		(
			i   := i - 1;
			comb  := res + i;
		);
		return res;
	);


-- --@doc resets safe to initial positon
-- resetSafe() == 
-- 	(safe := nil)
-- ext wr safe
-- post safe = GOOD_SAFE;
	
-- --@doc configures the safe to a specific initial value
-- configureSafe(s: Safe) == 
-- 	--@todo
-- 	is not yet specified
-- ext wr safe
-- pre
-- 	--@todo
-- 	true 
-- post 
-- 	safe = s;

-- openSafe() c: Combination ==
-- 	--@todo 
-- 	is not yet specified
-- ext rd safe
-- pre
-- 	--@todo
-- 	true
-- post
-- 	--@todo
-- 	true;

-- revealValues(c: Combination) r: ? ==
-- 	is not yet specified
-- ext rd safe;
	
-- --@todo
-- traces


end SafeCrackerStd