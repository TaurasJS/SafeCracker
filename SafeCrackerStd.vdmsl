module SafeCrackerStd
exports all
definitions 

--@doc R1 represent the safe cracker generally (e.g. N wheels and M spokes) 
--@doc R1.1 instantiate the safe cracker to specific configuration 
--@doc R1.2 instantiate the wheels (4) and spokes (16) 

--@doc R2 find the safe combination/configuration to open the safe
--@doc R3 ensure that at least one combination exists
--@doc R4 capture the safe properties in your design
--@doc R5 ensure that the safe development is satisfiable

--@doc suggested configuration with certain openning combination
--	   this also suggests a fixed notion of spokes (i.e. where is 1st spoke)?
--	   OUTER = 27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10
--	   MID2  =  5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3
--	   MID1  = 10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10
--     INNER = 10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24
--
--	   certain wheels have overlays over intermitent spokes
--	   again this requires a notion of spoke positioning 
--	   MID1_OVERLAY  = 10,  2, 12, 17, 16, 9, 9, 15
--	   MID2_OVERLAY  =  1, 22,  6, 24, 24, 7, 5, 27
--     INNER_OVERLAY =  5,  4,  6,  6, 10, 1, 6,  4	
--
--	   secret sum is 40, yet also a game parameter

values
	MAX_WHEELS: nat1 = 4;
	MAX_SPOKES: nat1 = 16;
	SECRET_SUM: nat1 = 40;
	
types

	Value = nat1
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v <= SECRET_SUM - MAX_WHEELS + 1;

	Collumnsum = nat1
	inv c == c <= SECRET_SUM;

	OverValue = nat1 | <Empty>
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v = <Empty> or v <= SECRET_SUM - MAX_WHEELS + 1;

	Rotate = nat
	inv r == r <= MAX_SPOKES and r >= 0;
	
	Spokes = nat1 
	--@todo how many spokes are possible?
	inv s == s <= MAX_SPOKES;
	
	Wheel = seq of Value
	inv w == len w = MAX_SPOKES; -- length of wheel must be equal to max spokes for the integrity of the game

	Overwheel = seq of OverValue
	inv ow == len ow = MAX_SPOKES; -- length of overlay wheel of non empty values is equal to MAX_SPOKES, half of them are filled out as <Empty>
	--@todo would you need to represent the wheels in combination?
	Wheels = seq of Wheel
	inv ws == len ws <= MAX_WHEELS; -- ammount of wheels must be equal or less to the MAX_WHEELS
	
	--@todo depending on design decisions you may need a notion of Overlay?
	Overlay = seq of Overwheel
	inv ovl == len ovl < MAX_WHEELS;
	
	-- Safe = set of Overwheel * set of Wheels
	-- inv s == card s.#1 <= card s.#2;
	
	Safe = Overlay * Wheels
	inv mk_(o, w) == len o = len w-1;

	--@todo a safe is not a combination; but a combination is part of a safe? 
	--in my case combinationn is 4 sequences of wheels that we would see if we saw the safe cracker puzzle from top-down. (wheels and overhweels combined).
	Combination = Wheels
	inv c == len c = 4;--???

	Rotations =  seq of Rotate
	inv r == len r = 3; -- First OUTER and MID2 don't rotate. Rotations are how many times other circle combinations (of inner and outer connected layers) were roateted, max 16 times.

values
	--GOOD_SAFE.#1(1) = 				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],

	GOOD_SAFE: Safe = mk_(
			[
				--INNER_OVERLAy
				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],
				--MID1_OVERLAY
				[1, <Empty>, 22, <Empty>, 6, <Empty>, 24, <Empty>, 24, <Empty>, 7, <Empty>, 5, <Empty>, 27,<Empty>],
				--MID2_OVERLAY
				[5, <Empty>, 4, <Empty>, 6, <Empty>, 6, <Empty>, 10, <Empty>, 1, <Empty>, 6, <Empty>, 4, <Empty>]
			],
			-- seq of seq of Value
			-- <= 4   = 16   
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);

		--Starting combination is equal to the default 4 wheels of safe. Just for the clarity. Not actual values
		--Only OUTER wheel is correct because it is not touched in my functions.
		STARTING_COMBINATION: Combination =(
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);


functions


	--Following function sums up values of one collumn in a combination (Top down view of safe).
	-- c - combination, v - current value starts at 0, cn - collumn number,
	-- sn - sequence number, starts from 1
	--Values for that collumn are summed up.
	sum_collumn: Combination * nat * nat1 * nat1 -> nat1
	sum_collumn(c, v, cn, sn) == 
			if sn <> MAX_WHEELS
			then(
				sum_collumn(c, v+c(cn), cn, sn+1)
			)
			else
				v+c(cn);


	--Checks if all collumn values in the current combination (top down reult of a specific rotation) equals to 40.
	--Returns True if it is.
	check_values: Combination -> bool
	check_values(x) == forall i in set {1,...,MAX_SPOKES} & sum_collumn(x, i) = SECRET_SUM;



	--Overwrite function to be used in To_combination functions.
	OverwritenWheel: Wheel * Value * nat1 -> Wheel
	OverwritenWheel(w, v, n) == w++{n |-> v}; --NoteToMyself: Used overriding.



	To_combination_line: Wheel * Overwheel * nat1 -> Wheel -- TO ASK: no measure??
	To_combination_line(w, ow, n) == 
		let
			placement: Wheel = w
		in
			if n = MAX_SPOKES 
				then( -- If last recursion
					if ow(n) <> <Empty> 
					then 
						(
							OverwritenWheel(w, ow(n), n)
						) 
					else
						placement
				)
				else
					if ow(n) <> <Empty> --If not last recursion
					then 
						(
							To_combination_line(OverwritenWheel(w, ow(n), n), ow, n+1)
						) 
					else
						To_combination_line(placement, ow, n+1);

	

	To_combination_Full: Safe * Combination * nat1 -> Combination
	To_combination_Full(s, c, n) ==
			if n = MAX_WHEELS-1
				then( 
					c++{n |-> To_combination_line(s(2)(n), c(n), 1)} --ASK ABOUT: why Safe cannot be applied?
					/*
					For debugging,
					IN NORMAL CODE SHOULD BELIKE THAT:
					placementcomb(n) := SafeToCombinationLine(s(2)(n), c(n), 1);
					return placementcomb;*/
				)
				else
					To_combination_Full(s, c++{n |-> To_combination_line(s(2)(n), c(n), 1)}, n+1);
					/* 
					For debugging,
					IN NORMAL CODE SHOULD BELIKE THAT:
					placementcomb(n) := SafeToCombinationLine(s(2)(n), c(n), 1);
					return SafeTocombinationFull(s, placementcomb, n+1); */

		

	safe_to_combination: Safe * Combination -> Combination 
	safe_to_combination(s, c) == To_combination_Full(s, c, 1); --ASK ABOUT

	Turn: Wheel | Overwheel -> Wheel | Overwheel
	Turn(line) ==
	--This function will be used twice in a row, since when a wheel is turned so does it's connected overwheel
		let
			number: seq of nat1 | <Empty> = [hd line], -- ASK ABOUT THIS, WILL THIS MAKE A SEQUENCE WITH ONE ELEMENT?
			newline: seq of nat1 | <Empty> = tl line
		in
			newline^number;


	--For some reason this does not show Errors but is it correct, TO ASK.
	TurnSafeOperation: Safe * nat1 -> Safe
	TurnSafeOperation(s, n) ==
	let
		ow: Overwheel = s(1)(n+1),
		w: wheel = s(1)(n)
	in
		s(1)++{s(1)(n+1) |-> Turn(s(1)(n+1))} and s(2)++{s(2)(n) |-> Turn(s(2)(n))};




	InitCheckRotations: Safe * Rotations -> Rotations
	InitCheckRotations(s, r) ==
		if check_values(To_combination_Full(s, STARTING_COMBINATION, 1)) = true --IF SAFE IS GOOD RETURNS ROTATION
		then( 
			[1,1,1] --RETURNS [1,1,1] wheels were not moved
		)

	Exists: Rotations -> bool --??????? throws error for if, tried all TO ASK
	Exists(r) ==
		if r <> [0,0,0] 
		then
			true
		else
			false;

	CheckNonEdge: Safe * Rotations * nat1 -> Rotations --Pre: not first single overwheel or last wheel -> nat1 != 1 or MAX_WHEELS-2
	CheckNonEdge(s, r, n) ==
		if n >= MAX_WHEELS-2
		then(
			[0,0,0] --if reached edge case return zeroes meaning none were found 
		)
		else
		(
			if check_values(To_combination_Full(s, STARTING_COMBINATION, 1)) = true --checks if needs to be turned
			then 
				r  --returns unturned rotations sequence.
			else
				(
				if r(n) <> MAX_SPOKES
					then( 
						-- Turns overwheel
						--s(1)++{s(1)(n+1) |-> Turn(s(1)(n+1))}

						-- Turns wheel
						--s(2)++{s(2)(n) |-> Turn(s(2)(n))}

						--placementRotations(2) := rot(2)+1; -- updates rotation

						CheckNonEdge(TurnSafeOperation(s,n), r++{r(n) |-> r(n)+1}, n)
					)
					else
						--starts checking next wheel and overwheel pair.
						CheckNonEdge(TurnSafeOperation(s,n+1), r, n+1)
				)
		);

	FindAndEnsure: Safe * Rotations * nat1 -> Rotations
	FindAndEnsure(s, rot, n) == --@Todo add beggining and last check.
		if check_values(To_combination_Full(s, STARTING_COMBINATION, 1)) = true
		then (
			rot
		)
		else -- first wheel (overwheel) turns (beggining edge case).
		(
				if n = 1
				then(
					if rot(n) <> MAX_SPOKES 
						then 
							FindAndEnsure(TurnSafeOperation(s,n), rot++{rot(1) |-> r(1)+1}, n)
						else
							FindAndEnsure(TurnSafeOperation(s,n), rot, n+1) -- goes to non edge cases
				)
				else -- begins non edge cases
					if Exists(CheckNonEdge(s, rot, n)) -- does this function updates local rotation and n? TO ASK
					then 
						rot 
					else -- Begins final wheel edge case
						if rot(n) <> MAX_SPOKES 
						then 
							FindAndEnsure(TurnSafeOperation(s,n), rot++{rot(1) |-> r(1)+1}, n)
						else
							[0,0,0] -- if even after final edge case none were returned then returns zeroes which means no solution
		)

	--ALSO NEED TEXT REVEALING OPERATION OR FUNCTION.



-- ASK DURING PRACTICAL: Why is it impure operation if it is a recursive one?

	/*f: seq of seq of int -> seq of int 
	f(s) == 
		let 
			inner: Wheel = s(2)(1),
		    mid1 : Wheel = s(2)(2) 
		in
			inner ^ mid1   ;

	f(s) == s(2)(1) ^ s(2)(2)

	g: set1 of int -> int 
	g(s) == 
		let x in set s 
			be st (forall i in set s \ {x} & x <= i) 
		 in 
		 	x;
	*/
			

	/*initial_safe: () -> Safe
	initial_safe() == GOOD_SAFE -- maybe, useless. Consider deleting function.
	pre
		--@todo
		true
	post
		--@todo
		true;
		
	--@doc realises requirement R3
	combinations: Safe -> set of Combination
	combinations(s) ==
		--@todo
		is not yet specified
	pre true --@todo
	post true;--@todo

	valid_safe: Safe -> bool
	valid_safe(s) == 
		combinations(s) <> {}; */


--------------------------------------------------------------------------------------
--@doc you don't need the part below; 
--     it's useful for those who struggle with functions alone!
--------------------------------------------------------------------------------------

-- state State of
-- 	safe: [Safe]
-- 	sum: nat1
-- inv mk_State(-, sum) == 
-- 	--@todo document system invariants
-- 	sum <= SECRET_SUM
-- 	--and 
-- 	--(safe <> nil => valid_safe(safe))
-- init s == 
-- 	--@todo choose adequate initialisation: nil will fail invariant. 
-- 	s = mk_State(nil, SECRET_SUM)  
-- end

state S of 
	x: nat 
init s == s = mk_S(0)
end 

operations

/*SafeToCombinationOperation(s: Safe) r: Combination == -- Example 
	(
		dcl comb: Combination := STARTING_COMBINATION;

		for i = 1 to MAX_WHEELS-1 by 1 do
				for j = 1 to MAX_SPOKES by 1 do
					if s.#1(i)(j) <> <Empty> 
					then( 
						comb(i)(j) := s.#1(i)(j)
					)
					else
						comb(i)(j) := s.#2(i)(j);
		return comb;
	);*/
			/* 
SafeTocombinationFull(s: Safe, c: Combination, n: nat1) r: Combination ==
	(
		-- ASK ABOUT ERRORS WHEN USING s RECURSIVE FUNCTIONS
		-- Requires pre condition that c = STARTING_COMBINATION
		-- Requires pre condition that n = 1
		dcl placementcomb: Combination := c; -- placement Combination to avoid errors. Will be returned after recursion is done

		if n = MAX_WHEELS-1 
		then( 
			placementcomb(n) := SafeToCombinationLine(s(n), c(n), 1); -- WHY SAFE cannot be applied ASK!!
			return placementcomb;
		)
		else
			placementcomb(n) := SafeToCombinationLine(s(n), c(n), 1);
			return SafeTocombinationFull(s, placementcomb, n+1);
	);

SafeToCombinationLine(w: Wheel, ow: Overwheel, n: nat1) r: Wheel ==
	(
		-- Requires pre condition that n = 1
		dcl placement: Wheel := w; -- placement wheel to avoid errors. Will be returned after recursion is done

		if n = MAX_SPOKES 
		then( -- If last recursion
			if ow(n) <> <Empty> 
			then 
				(
					placement(n) := ow(n);
					return placement;
				) 
			else
				return placement;
		)
		else
			if ow(n) <> <Empty> 
			then 
				(
					placement(n) := ow(n);
					return SafeToCombinationLine(placement, ow, n+1);
				) 
			else
				return SafeToCombinationLine(placement, ow, n+1);
	);

--ASK ABOUT ALL OF THIS CLUSTER???
CheckAndReturn(s: Safe, rot: Rotations) r: Rotations == 
	(
		--Requires starting value for r = [1,1,1]
		dcl placementsafe: Safe := s;
		dcl placementRotations: Rotations := rot;

		if check_values(SafeTocombinationFull(s, STARTING_COMBINATION, 1)) = true --IF SAFE IS GOOD RETURNS ROTATION
		then( 
			return placementRotations; --RETURNS [1,1,1] wheels were not moved
		)
		else
			if rot = [MAX_SPOKES, MAX_SPOKES, MAX_SPOKES] --IF reached final combination
			then( 
				if check_values(SafeTocombinationFull(s, STARTING_COMBINATION, 1)) = false 
				then( 
					return [0,0,0];
				)
			)


			--RECURSIVE PART STARTS FROM DOWN HERE BELOW, FROM THE INNER OVERLAY. STILL THE SAME INITIAL IF CHAIN.
			--Starts if it is not the very final rotation.


			else
				if rot(1) <> 16
				then ( -- Turns inner overwheel once and repeats the loop to see if they get a correct combination
					placementsafe(1)(1) := Turn(s(1)(1));
					placementRotations(1) := rot(1)+1;
					return CheckAndReturn(placementsafe, placementRotations);
				)
				else
					if rot(2) <> 16
					then( 
						placementsafe(1)(2) := Turn(s(1)(2)); -- Turns wheel
						placementsafe(2)(2) := Turn(s(2)(2)); -- Turns overwheel
						placementRotations(2) := rot(2)+1;
						return CheckAndReturn(placementsafe, placementRotations);
					)
					else
						if	rot(3) <> 16
						then( 
								placementsafe(1)(3) := Turn(s(1)(3)); -- Turns wheel
								placementsafe(2)(3) := Turn(s(2)(3)); -- Turns overwheel
								placementRotations(3) := rot(3)+1;
								return CheckAndReturn(placementsafe, placementRotations);
							) 
	);  */


-- --@doc resets safe to initial positon
-- resetSafe() == 
-- 	(safe := nil)
-- ext wr safe
-- post safe = GOOD_SAFE;
	
-- --@doc configures the safe to a specific initial value
-- configureSafe(s: Safe) == 
-- 	--@todo
-- 	is not yet specified
-- ext wr safe
-- pre
-- 	--@todo
-- 	true 
-- post 
-- 	safe = s;

-- openSafe() c: Combination ==
-- 	--@todo 
-- 	is not yet specified
-- ext rd safe
-- pre
-- 	--@todo
-- 	true
-- post
-- 	--@todo
-- 	true;

-- revealValues(c: Combination) r: ? ==
-- 	is not yet specified
-- ext rd safe;
	
-- --@todo
-- traces


end SafeCrackerStd