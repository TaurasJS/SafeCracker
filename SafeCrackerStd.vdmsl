module SafeCrackerStd
imports from IO		 operations  println	renamed println;
exports all
definitions 

--@doc R1 represent the safe cracker generally (e.g. N wheels and M spokes) 
--@doc R1.1 instantiate the safe cracker to specific configuration 
--@doc R1.2 instantiate the wheels (4) and spokes (16) 

--@doc R2 find the safe combination/configuration to open the safe
--@doc R3 ensure that at least one combination exists
--@doc R4 capture the safe properties in your design
--@doc R5 ensure that the safe development is satisfiable

--@doc suggested configuration with certain openning combination
--	   this also suggests a fixed notion of spokes (i.e. where is 1st spoke)?
--	   OUTER = 27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10
--	   MID2  =  5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3
--	   MID1  = 10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10
--     INNER = 10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24
--
--	   certain wheels have overlays over intermitent spokes
--	   again this requires a notion of spoke positioning 
--	   MID1_OVERLAY  = 10,  2, 12, 17, 16, 9, 9, 15
--	   MID2_OVERLAY  =  1, 22,  6, 24, 24, 7, 5, 27
--     INNER_OVERLAY =  5,  4,  6,  6, 10, 1, 6,  4	
--
--	   secret sum is 40, yet also a game parameter

values
	MAX_WHEELS: nat1 = 4;
	MAX_SPOKES: nat1 = 16;
	SECRET_SUM: nat1 = 40;
	
types

	Value = nat1
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v <= SECRET_SUM - MAX_WHEELS + 1;

	Collumnsum = nat1
	inv c == c <= SECRET_SUM;

	OverValue = nat1 | <Empty>
	--@todo what about other wheels? what if it goes beyond 40 when summing? 
	inv v == v = <Empty> or v <= SECRET_SUM - MAX_WHEELS + 1;

	Rotate = nat
	inv r == r <= MAX_SPOKES and r >= 0;
	
	Spokes = nat1 
	--@todo how many spokes are possible?
	inv s == s <= MAX_SPOKES;
	
	Wheel = seq of Value
	inv w == len w = MAX_SPOKES; -- length of wheel must be equal to max spokes for the integrity of the game

	Overwheel = seq of OverValue
	inv ow == len ow = MAX_SPOKES; -- length of overlay wheel of non empty values is equal to MAX_SPOKES, half of them are filled out as <Empty>
	--@todo would you need to represent the wheels in combination?
	Wheels = seq of Wheel
	inv ws == len ws <= MAX_WHEELS; -- ammount of wheels must be equal or less to the MAX_WHEELS
	
	--@todo depending on design decisions you may need a notion of Overlay?
	Overlay = seq of Overwheel
	inv ovl == len ovl < MAX_WHEELS;
	
	-- Safe = set of Overwheel * set of Wheels
	-- inv s == card s.#1 <= card s.#2;
	
	Safe = Overlay * Wheels
	inv mk_(o, w) == len o = len w-1;

	--@todo a safe is not a combination; but a combination is part of a safe? 
	--in my case combinationn is 4 sequences of wheels that we would see if we saw the safe cracker puzzle from top-down. (wheels and overhweels combined).
	Combination = Wheels
	inv c == len c = 4;--???

	Rotations =  seq of Rotate
	inv r == len r = 3; -- First OUTER and MID2 don't rotate. Rotations are how many times other circle combinations (of inner and outer connected layers) were roateted, max 16 times.

values
	--GOOD_SAFE.#1(1) = 				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],

	GOOD_SAFE: Safe = mk_(
			[
				--INNER_OVERLAy
				[10, <Empty>, 2, <Empty>, 12, <Empty>, 17, <Empty>, 16, <Empty>, 9, <Empty>, 9, <Empty>, 15, <Empty>],
				--MID1_OVERLAY
				[1, <Empty>, 22, <Empty>, 6, <Empty>, 24, <Empty>, 24, <Empty>, 7, <Empty>, 5, <Empty>, 27,<Empty>],
				--MID2_OVERLAY
				[5, <Empty>, 4, <Empty>, 6, <Empty>, 6, <Empty>, 10, <Empty>, 1, <Empty>, 6, <Empty>, 4, <Empty>]
			],
			-- seq of seq of Value
			-- <= 4   = 16   
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);

		--Starting combination is equal to the default 4 wheels of safe. Just for the clarity. Not actual values
		--Only OUTER wheel is correct because it is not touched in my functions.
		STARTING_COMBINATION: Combination =(
			[
				--INNER
				[10,  1, 10, 12, 10, 10,  3, 17,  3, 10, 13,  1,  6,  8, 10, 24],
				--MID1
				[10, 17,  5, 19,  4,  3, 15, 13, 17, 10,  2, 20, 15,  6,  2, 10],
				--MID2
				[5,  9, 10,  2,  6,  1, 27, 10, 10,  6,  6,  9,  3,  3,  8,  3],
				--OUTER
				[27, 11, 20, 27,  3,  2,  3, 19, 23,  2, 10, 15, 13, 10, 19, 10]
			]
		);


functions


	--Following function sums up values of one collumn in a combination (Top down view of safe).
	-- c - combination, v - current value starts at 0, cn - collumn number,
	-- sn - sequence number, starts from 1
	--Values for that collumn are summed up.
	sum_collumn: Combination * nat * nat1 * nat1 -> nat1
	sum_collumn(c, v, cn, sn) == 
			if sn <> MAX_WHEELS
			then(
				sum_collumn(c, v+c(sn)(cn), cn, sn+1)
			)
			else
				v+c(sn)(cn);


	--Checks if all collumn values in the current combination (top down reult of a specific rotation) equals to 40.
	--Returns True if it is.
	check_values: Combination -> bool
	check_values(x) == forall i in set {1,...,MAX_SPOKES} & sum_collumn(x, 0, i, 1) = SECRET_SUM;


	Turn: Wheel | Overwheel -> Wheel | Overwheel
	Turn(line) ==
	--This function will be used twice in a row, since when a wheel is turned so does it's connected overwheel
		let
			number: seq of nat1 | <Empty> = [hd line], -- ASK ABOUT THIS, WILL THIS MAKE A SEQUENCE WITH ONE ELEMENT?
			newline: seq of nat1 | <Empty> = tl line
		in
			newline^number;

	InitSafe: () -> Safe
	InitSafe() == GOOD_SAFE;


-- ASK DURING PRACTICAL: Why is it impure operation if it is a recursive one?

	/*f: seq of seq of int -> seq of int 
	f(s) == 
		let 
			inner: Wheel = s(2)(1),
		    mid1 : Wheel = s(2)(2) 
		in
			inner ^ mid1   ;

	f(s) == s(2)(1) ^ s(2)(2)

	g: set1 of int -> int 
	g(s) == 
		let x in set s 
			be st (forall i in set s \ {x} & x <= i) 
		 in 
		 	x;
	*/
			

	/*initial_safe: () -> Safe
	initial_safe() == GOOD_SAFE -- maybe, useless. Consider deleting function.
	pre
		--@todo
		true
	post
		--@todo
		true;
		
	--@doc realises requirement R3
	combinations: Safe -> set of Combination
	combinations(s) ==
		--@todo
		is not yet specified
	pre true --@todo
	post true;--@todo

	valid_safe: Safe -> bool
	valid_safe(s) == 
		combinations(s) <> {}; */


--------------------------------------------------------------------------------------
--@doc you don't need the part below; 
--     it's useful for those who struggle with functions alone!
--------------------------------------------------------------------------------------

-- state State of
-- 	safe: [Safe]
-- 	sum: nat1
-- inv mk_State(-, sum) == 
-- 	--@todo document system invariants
-- 	sum <= SECRET_SUM
-- 	--and 
-- 	--(safe <> nil => valid_safe(safe))
-- init s == 
-- 	--@todo choose adequate initialisation: nil will fail invariant. 
-- 	s = mk_State(nil, SECRET_SUM)  
-- end

state S of 
	x: nat 
init s == s = mk_S(0)
end 

operations

TurnSafeOperation(s: Safe, n: nat1) r: Safe ==
(
		dcl ow: Overlay := s.#1;
		dcl w: Wheels := s.#2;
		
		
		ow(n+1) := Turn(ow(n+1));
		w(n) := Turn(w(n));

		return mk_(ow, w); --no error on home machine, error on cluster machine. Inquire during practical TODO!!!
);

SafeToCombinationOperation(s: Safe) r: Combination == -- Example 
	(
		dcl comb: Combination := STARTING_COMBINATION;

		for i = 1 to MAX_WHEELS-2 by 1 do
				for j = 1 to MAX_SPOKES by 1 do
					if s.#1(i)(j) <> <Empty> 
					then( 
						comb(i)(j) := s.#1(i)(j);
					)
					else
						comb(i)(j) := s.#2(i)(j);
		return comb;
	);


CheckThroughFollowing(s: Safe, n: nat1, rot: Rotations) r: Rotations == -- checks through all possible combinations for that one move. To be used in CheckAndReturn Operation.
	(
		dcl placementsafe: Safe := s;
		dcl placementrotations: Rotations := rot;

		for i = n to MAX_WHEELS-2 by 1 do
		(
			for j = 1 to MAX_SPOKES by 1 do
			(
				if(check_values(SafeToCombinationOperation(placementsafe))) = true -- if finds, returns rotations and loop breaks.
					then(
						return placementrotations;)
					else
						(
							placementsafe := TurnSafeOperation(placementsafe, i);
							placementrotations(i) := j;
						)
			)
		);
		return rot; -- returns unchanged roation if earlier loop does not return a changed (placement) rotation.
	);

CheckAndReturn(s: Safe, rot: Rotations) r: Rotations ==
	(
		dcl placementsafe: Safe := s;
		dcl placementow: Overlay := s.#1;
		dcl placementws: Wheels := s.#2;
		dcl placementrotations: Rotations := rot;

		for i = 1 to MAX_WHEELS-2 by 1 do
		(
			for j = 1 to MAX_SPOKES by 1 do(
				if i = 1
					then(
						if(check_values(SafeToCombinationOperation(placementsafe))) = true -- if initial value is solution, returns rotation and loop breaks.
						then(
							return placementrotations;
							)
						else(
							placementow(i) := Turn(placementow(i)); -- placement safe is updated
							placementsafe := mk_(placementow, placementws);

							if CheckThroughFollowing(placementsafe, i, placementrotations) <> placementrotations
								then(
									placementrotations := CheckThroughFollowing(placementsafe, i, placementrotations);
									return placementrotations;
								)
						)
					)
				else -- if not first wheel (not a single overwheel turned but both)
					(
						if(check_values(SafeToCombinationOperation(placementsafe))) = true --checks starting value
						then
						(
							return placementrotations; -- returns if good unturned
						)
						else -- turns both wheel and overwheel
						(
							placementsafe := TurnSafeOperation(placementsafe, i);
							--checks through following possible combinations
							if CheckThroughFollowing(placementsafe, i, placementrotations) <> placementrotations
								then(
									placementrotations := CheckThroughFollowing(placementsafe, i, placementrotations);
									return placementrotations;
								)
						)
					)
			)
		);
		return [0,0,0]; -- Returns zeroes if no good combination was found. (No solution found)
	);

	Solutioning(s: Safe) ==
	(
		dcl rot: Rotations := CheckAndReturn(s, [1,1,1]);

		if rot <> [0,0,0]
		then(
			print("Found a solution rotation: " ^ rot);
		)
		else
			print("No possible solutions for this safe");
	)

	/* BRING HOME MACHINE TO THE PRACTICAL, ASK WHY NO ERRORS SHOWN WHEN ERRORS WERE PRESENT ON CLUSTER MACHINES??
						ASK ABOUT "NO SUCH MODULE AS IO" */


-- --@doc resets safe to initial positon
-- resetSafe() == 
-- 	(safe := nil)
-- ext wr safe
-- post safe = GOOD_SAFE;
	
-- --@doc configures the safe to a specific initial value
-- configureSafe(s: Safe) == 
-- 	--@todo
-- 	is not yet specified
-- ext wr safe
-- pre
-- 	--@todo
-- 	true 
-- post 
-- 	safe = s;

-- openSafe() c: Combination ==
-- 	--@todo 
-- 	is not yet specified
-- ext rd safe
-- pre
-- 	--@todo
-- 	true
-- post
-- 	--@todo
-- 	true;

-- revealValues(c: Combination) r: ? ==
-- 	is not yet specified
-- ext rd safe;
	
-- --@todo
-- traces


end SafeCrackerStd